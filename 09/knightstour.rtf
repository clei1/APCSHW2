{\rtf1\ansi\ansicpg1252\cocoartf1504\cocoasubrtf810
{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\margl1440\margr1440\vieww28600\viewh18000\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf0 Connie Lei\
APCS2 pd1\
HW#09 \'97 Get On The Bus\
2017-02-28\
\
Algorithm for generating knights\'92 tour:\
\
1. Create a 2D integer array with length n.\
2. Choose to populate the first possible tile in the first row.\
3. Generate another 2D integer move array with possible moves, checking all 8 spots. Only the spots that are within the bounds of the board and not already been visited (check if it is positive) are allowed into the array.\
4. Start the branching there by having a for loop to run through each of the possible moves in the move array. Within the array, it will be a nested function that calls itself again to generate the possible lists.\
For example, if you start with (0,0) being occupied, a 2D array with be created with [[2, 1], [1,2]]. A for loop will iterate through the board array, placing another knight at [2,1] and then having that position evaluate its possible move paths.\
The possible paths will be [[4, 0], [4, 2], [3, 3], [1, 3], [0, 2]]. The for loop with create another branch into [4,0] and then create so on. When a knight is placed at a new position, it will update the number of tiles the knight has visited and place that number on the tile.\
This means [0, 0] will be 1 and [2, 1] would be 2.\
5. Repeat steps 3 and 4 continuously until you reach the number n^2 which means it is possible, or until you reach a position where the 2D move array is empty. If the 2D move array is empty, you will remove that knight from the board by changing the position it was at back to 0. Then that branch will finish and go up to the last possible branch.\
6. In order for you to find an open/closed solution, you can simply create a check that invalidates a solution if the last piece is not at the end.\
7. For each spot on the board(or rather quadrant because you can rotate the board to find all possibilities), you can repeat steps 2 to 6 until you have exhausted all possible placements for knights in the first row. You would then move onto the second row and so on, repeating the same steps for 2 to 7 until you reach the opposite corner from where you started.\
\
Few things:\
Spots will be marked with a 0 (meaning untouched) or a positive number (indicating at what position the knight reached it).\
Removal of the knight or going back up/delayed operations means you don\'92t need to remove that option from the board because branches are unique. You simply need to set the spot to 0 again instead of the removeQueen method.\
You would only need to do a quadrant of the board, usually (int) ((n + 1)/ 2) because rotations.\
There is a possible way of generating the 2D move array, because you can have int row, int col and then have the first possible be row - 1, col - 2 etc.}